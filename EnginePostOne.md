# Blog Post #1: Getting Started

The engine I plan on creating will be the first one that I've ever created on my own and I'm excited to get started working on it. In a previous class I took called game architecture, I focused on how to make a basic framework which focused on having its core systems be as decoupled from one another as possible and to implement code structures which supported the game that I was making. The first game that I made was a simple sake game, and for the final project I worked with a partner to recreate the first dungeon of the original Zelda from scratch. I remember working to four in the morning, working about ten hours straight, trying to get file saving and loading to work in the game. With all of the entities and small variables important to the gamestate, it was a tremendous undertaking to try to put in this part of the game as the very last thing. It was a terrible idea to implement this system last, but in hindsight, I loved everything about that project, even working late into the morning that one time. By far, the content I learned in that class and the projects that I did is some of the most fun I've had as a game programmer. At times the content was hard and it took me some time to grasp the knowledge, but in the end I came out with one of the three core principles that I have as a programmer: _There are many ways to answer one problem, some will be better than others, but it depends on the needs of what you're making._

The problem with game architecture though, is that even though both the snake and Zelda game had simular components making up its structure, they had to be built completely different ways because of what the game required from those components. So the unit manager for example kept track of the snake parts, pickups, and walls within the snake game, but in the Zelda game it also had to keep track of all the different objects in the Zelda dungeon itself. What this causes is that even though there are parts that stay relatively the same, such as whatever graphical interface rendered the sprites on the screen, most of the codebase had to be removed per project to fit the projects needs. Therefore, making an engine is the next step I want to take, where the engine itself does not have to be tied directly to the game that the code it is being used for. At the same time, I can keep that same core principle to heart, but this time instead of the problem being how to create a codebase for one game, I can focus on what is the best for a codebase for any game that wants to be built on top of the engine. Therefore, I want to focus on creating the most flexible engine as possible that can support many types of games that could be built using it, and allow for the interchanging of plugins as well.

So looking into the differnt IDE for the game engine, the main thing that I want to look for is something that is cross platform so that the games made can work on as many platforms as possible. What this means though is that because I want to go as wide-range as possible, the IDEs and engine will run a little bit slower because the engine needs to conform to whatever platform that its running on Currently however, I am not too sure what IDEs I want to use for my engine. The engine will run C++ as the language itself is cross-platform, but components of the engine like the rendering will need to use outside tools because to start, I am not going to write an entire rendering component to my engine. So far the only graphical IDE that I've uses has been SDL, but is not a 3D graphics engine and only supports 2D. So for 3D I'm looking at Ogre as my IDE of choice. It has the cross platform support that I need, including both mobile and desktop platforms for both PC and Apple. The IDE is very well documented, and its free with an open source license. I think that I will start from there and start thinking about how I will need to structure my code to make it as flexible as possible.

[Return back to table of contents](https://telden.github.io/GameEngine)
