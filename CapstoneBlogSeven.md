Why Reinvent the Wheel? Why not try to Make a Wheel? Why not Make a Better Wheel?
------

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;During this week I copntinued the work on the AI for Arachnotron. I worked specifically on the two enemy types which will populate the game: the flyer enemies who attack the player at range and the charger enemies that will attack the player on the ground. I also began to think about how I was going to make a boss creature that the player will be crawling on be also accessible to the ground enemies to climb on and navigate. This task is difficult because the boss itself is an entity that is constantly moving, and therefore a navmesh object would have to be constantly updating which areas are accessible. A way that I considered to make this problem simpler is by not making using a navmesh at all, and instead either restict the enemies to one area on the boss's body, like its back for example, or by attaching nodes on the body that entities can path towards. The nodes would essencially act as the navmesh and would be able to move with the boss as it moves through space or when its going through some action/animation.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I wasn't too sure which approach I should take so I went to some of my professors to get their opinions and get input for what I should try to do. The first one I asked gave me a very high level answer. What I mean by this is that the answer to my problem is solved by using a simpler method, as this professor's philosphy seems to be keep it simple and don't reinvent the wheel when there are already tools availble to fix the problem. He proposed that the node idea would be good because I could use Bezier curves to describe the path from one node to the next on the boss' body and it would not require that much pathing to do this. I still have my node code that I had written a couple weeks ago which needs to be fixed, and I did consider fixing it as a way to create the movement on the boss. So maybe it could be a good idea to combine these two concepts.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The other professor is the opposite from the other, and he gave me a much more lower-level, more "close to the metal" type of answer. He suggested that I examine the problem in a 2D view, that the boss itself is just a collection of verticies connected together to make a model, and that if I flattened ot the whole object, I would get a map of points and connections between the points. I could try to make the model itself a navmesh, and let the other enemies path on the boss by using the data that is already there in the model itself Its a very interesting answer, but a lot more complicated than the other way to fix the problem.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This creates the biggest question: which method is the best path? One philosophy is don't reinvent the wheel because if there are already tools that can help, I shouldn't put more time into trying to recreate something that already works. The other path is one where reinventing the wheel shows that I fundementally understand how the tools that have been already created work in the first place, and by doing something more complicated it also shows my programming skills as well. It comes down to the issue of what I want out of my work in the project. By taking shortcuts, it reduces the time I need to spend on each task and therefore get more done for the project with hopefully the same final result. The downside to this is that it doesn't show anything special on a coding skill level because all I'm doing is using tools already made. The other path is the opposite, where I take more time to make something for the same results, but show off my understanding of more complicated concepts. I would say that I want to find a happy medium between these two. I want something that I can be proud of because it shows what I can do without having to take up too much time. For now I think that I will go back and clarify some details with these professors again and make the best decision that I feel is best for me from there.
