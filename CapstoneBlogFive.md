Moving Forwards With Arachnotron
------

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; During the previous sprint, the team had officially decided on Aracnotron, the game where the player controls a spider tank which fought against other bug mechonoids. During that sprint, Evan and I worked on the maze race game and brought an intial prototype to QA, which got mixed reviews compared to aracnotron. We had the testers play both the maze race game and the latest build of Aracnotron, and the QA feedback showed that the maze race game had a larger spread of respnses while Aracnotron had cohesive overall positive responses. The results supplimented what the team already felt like it was going to do anyway.  When Evan and I were  working on the maze game, we found that we were not enjoying the work as much as we enjoyed working on Aracnotron. For myself, I didn't  see any really cool overarching systems that I could enhoy making as the game  was built on many smaller ones that would come together to create an overall experience. Also, the work that needed to get game into a prototypable state was much larger than Aracnotron and this was because of the multiple smaller systems that needed to be created and work well with one another. The work for the maze game felt very tedious and unfun and would take a lot more work to get finished compared to Aracnotron which I do enjoy working on. The team mirrored my opinion and the maze game was scrapped for Arachnotron

This Weeks Work - Starting On the AI
---------
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;During my discipline meeting last week, we talked about what a programmer's job should be on their respective teams. The basic conclusion was that the prgrammer's job is to focus on the creation of systems and tools that the rest of the team can use to make their job's easier, while the designers should focus on the prototyping. This week was the first week where Evan and I split off for the first time and we got to work on our respective portions without having to work directly together. I'm honestly very happy about this because I enjoy making things work in the background, and don't find too much enjoyment in the main gameplay that's tied to the prototype. So I had a lot of fun during this weeks work.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; My task is to architect and create the AI and AI tools that will be used by the enemies, and for Evan to create the enemies that hw wants. The AI is arguably the technically riskiest part of the game as the the game's core concept requires a lot of enemy entities that the player can shoot down while traversing through levels. I honestly have not dealt with AI in Unity before, and I was worried that my inexperience would create problems because the AI is a critical component of the game. But during my work and research, I found that I did actually know a lot more than I had orginally thought. 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The AI for the game breaks down into multiple parts: First, there is the basic walking enemies. These enemies will walk along the ground and will attack the player if they get too close to them or when they are attacked. The tricky thing about them is that since they are also insects, will they have the ability to climb the walls around them as the player can? And maybe only certain types will have this ability. For these enemies, I plan on using Unity's navmesh assets to navigate them around the world. Its best to use this system because there is no reason to reinvent the wheel when the premade assets are already robust enough to work. The only trick is that Unity's navmesh might not know that the enemies should also climb walls, but I found resources detailing wys to make the walls also climbable and therefore makes this viable for the ground enemies. 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The next type of enemy are the flying enemies, and this was what my work is related to this week. Flying enemies have the unique issue that they have free 3D movement, and don't just move along a surface like the walking enemies do. And because they are flying, they don't use Unity's navmesh system either, so I had to create a system that could support these enemies. What I came up with is something that I'm really excited about because it combines all of my programming goals of being dynamic for both for gameplay, and as a tool. First, I created the node objects. These nodes act as specific points in the worldspace that the flying enemy can move towards. Next, I implemented a way to connect the nodes dynamically without anyone having to manually set the connections, which would take forever and would be a huge pain for the design pipeline. When the game was ran, the nodes would check if they could see one another with raycasts, and if they could they would connect themselves with that node. So for anyone making a level, all they would need to do is place the nodes in the worldspace, and thats it, the connections will make themselves. 

Here the blue lines represent that the two nodes see each other and they are connected.

![LineTest1](https://telden.github.io/images/BlueLine.PNG)

Here the red lines mean that they tried to conncet, but the wall blocks their line of sight and therefore cannot connect.

![LineTest2](https://telden.github.io/images/RedLine.PNG)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now that the nodes have made connections to one another, this has created the "node graph" within the world space. The next step is to create a way for the enemies to be able to use this node graph to move around. I originally was planning on making a A* or Dijkstra algorithm for the AI pathing, but I came up with something a lot better I think. I figured that having all the nodes make connections and all of the enemies AI doing the pathing durinig runtime would be too slow and may create system issues down the line. What if Evan wants to have a level that is just completely packed with enemies? All of these enemies doing pathing would create some sort of system slowdown at some point. So what I created was a custom editor window that would do a couple of things: It creates all of the connections between the nodes, and it contructs every possible path between these nodes automatically in the editor before the game is even ran. This happens all with a push of one button. The benefits of doing this is that this will support a lot of enemies if Evan wants to create levels packed full of them. Instead of having to do pathing algorithms, all the AI needs to do is have the start node (their current node) and the end node (the node the player is closest to). They give these two points to the grid graph and it will give them a premade set of instructions of the best path from where they are to the player which had been created already. The downsides I see with this system is that it trades memory consumption for speed of the AI, because the system needs to save the information of every path from each node possible, and the other is that this system currently does not support dynamically shifting levels, so the levels will have to be static for it to work. Evan says that currently he isn't planning on there being any dynamicly shifting levels for this semester's work, but it will have to be something that I will look into in the future.


Here by clicking the button, the connections are made between the ndoes and best paths found all within the editor.

![Demo Gif](https://media.giphy.com/media/EEwyZNDiF6pFX9eqgM/giphy.gif)
